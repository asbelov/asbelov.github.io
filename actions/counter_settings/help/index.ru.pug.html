<!--Created by Alexander Belov on 18.04.2020.
 Copyright (C) 2020. Alexander Belov. Contacts: <asbel@alepiz.com>
--><!DOCTYPE html><html lang="ru" xml:lang="ru" xmlns="http://www.w3.org/1999/xhtml"><head><title>Counter settings: создание или редактирование счетчиков. Подробное описание счетчиков</title><link rel="stylesheet" href="../../../materialize-css/dist/css/materialize.css"><link rel="stylesheet" href="../../../material-design-icons/material-icons.css"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><meta name="author" content="Alexander Belov &amp;lt;asbel@alepiz.com&amp;gt"><script src="../../../materialize-css/dist/js/materialize.js"></script><script src="../../../javascripts/help.js"></script></head><body><header><div class="row"><div class="col s12 m10 offset-m1"><h1>Counter settings</h1><h5 class="light">С помощью Counter settings можно редактировать или создавать счетчики.</h5></div></div></header><main><div class="row"><div class="col s10 m10 offset-m1"><img class="materialboxed card-panel hoverable" src="images/help.main.png" width="1024"><h2>Предназначение Counter settings</h2><p>Counter settings предназначен для создания, изменения, экспорта и импорта счетчиков.
Счетчик предназначен для сбора или генерации информации, которая может быть сохранена в базу
данных и обработана. Например, счетчиком может быть система сбора информации о свободной памяти
на сервере,
система сбора информации о статусе дисков в RAID контроллере, система генерации событий при
превышении счетчиком порогового значения, система поиска новых объектов в сети и так далее.
</p><h5>Возвращаемое значение: объект с данными счетчика:</h5><div class="card-panel"><pre>{
    initObjectsIDs: &lt;array of object IDs&gt;,
    counter: {
        name: &lt;counter name&gt;,
        collectorID: &lt;collector ID (directory name)&gt;,
        groupID: &lt;counter group ID&gt;,
        unitID: &lt;counter unit ID&gt;,
        keepHistory: &lt;keep history in days&gt;,
        keepTrends: &lt;keep trends in days&gt;,
        sourceMultiplier: &lt;source multiplier (from counter unit)&gt;,
        counterID: &lt;counter ID&gt;,
        description: &lt;counter description or null&gt;,
        disabled: &lt;enabled or disabled counter (1 or 0)&gt;,
        debug: &lt;enabled or disabled counter debug (1 or 0)&gt;,
        taskCondition: &lt;use counter as a task condition (1 or 0)&gt;,
        updateVariablesRef: &lt;oldCounterName: update variables references when counter name is changed&gt;
    },
    counterParameters: &lt;object with parameters for collector&gt;
        {
            &lt;name1&gt;: &lt;value1&gt;,
            &lt;name2&gt;: &lt;value2&gt;,
         ...},
    updateEvents: &lt;array with update events objects&gt;:
        [{
            counterID:,
            objectID:,
            expression:,
            mode:,
            objectFilter,
            description:,
            updateEventOrder:
        }, ...],
    variables: &lt;object with variables objects&gt;
        {&lt;variableName1&gt;: {
            variableOrder:,
            description:,
            expression:,
            parentCounterName:,
            objectID:,
            objectVariable:,
            function:,
            functionParameters
        }, ...},
}
</pre></div><h3>COUNTER</h3><p>Вкладка COUNTER позволяет настроить основные параметры счетчика, такие как имя, группу,
используемый сборщик, параметры сборщика, параметры сохранения и хранения собранной
информации в базу данных.</p><img class="materialboxed card-panel hoverable" src="images/help.counters.png"><h4>Filter counter by group</h4><p>Позволяет отфильтровать счетчики, выбрав определенную группу. Значение All groups, позволяет
выбирать все счетчики для выбранного или выбранных объектов.
Если объект не задан, то All groups позволяет выбирать вообще все счетчики.
</p><h4>Counters selector</h4><p>Позволяет выбрать требуемый счетчик из списка. Если необходимо создать новый счетчик,
выберите New counter. При необходимости скопировать часть настроек существующего счетчика в новый счетчик,
нужно выбрать счетчик, с которого необходимо скопировать настройки, а потом выбрать New counter.
Все настройки сохранятся в соответствующих полях</p><h4>Show counters only for selected collector</h4><p>Показывает только счетчики, использующие коллектор, выбранный в "Collector type"
</p><h4>Filter counters by objects</h4><img class="materialboxed card-panel hoverable" src="images/help.objectFilter.png"><p>Если в Filter counters by objects есть какой-то объект или объекты, в Counters selector будут
показаны счетчики, подключенные
к объектам из этого элемента. Если в системном меню Objects выбрать объекты, а затем запустить
Counter settings, выбранные объекты появятся в поле Filter counters by objects.
При необходимости можно добавить объекты в поле Filter counters by objects. Для этого нужно
выбрать объекты в системном меню Objects и нажать на ADD SELECTED OBJECTS.
Если нажать на крестик справа от объекта в поле Filter counters by objects, объект
будет удален. Удалить все объекты из Filter counters by objects можно нажав на REMOVE ALL OBJECTS.
</p><h4>Disable</h4><p>Если стоит этот признак, то сбор данных по выбранному счетчику производиться не будет.</p><img class="materialboxed card-panel hoverable" src="images/help.disableDebugDelete.png"><h4>Enable debug</h4><p>Enable debug позволяет собирать отладочную информацию о вычислениях переменных по данному счетчику.
Собранную информацию можно посмотреть в действии <a href="../../variables/help/index.html">Variables</a>.
По отладочной информации можно определить, каким образом вычисляются переменные счетчика.
Включение сбора отладочной информации может значительно
увеличить нагрузку на систему, что приведет к задержкам в
сборе информации. Сбор отладочной информации можно устанавливать не более чем на 10 счетчиков.
Желательно отказаться от сбора отладочной информации в системе, обслуживающей реальную инфраструктуру.
При нажатии на "Enable debug" открывается список счетчиков, в которых эта настройка включена.
Если нажать на счетчик из списка, в новом окне браузера откроется действие Counter settings с
выбранным счетчиком
</p><h4>Condition for task</h4><p>Позволяет использовать счетчик в качестве условия для выполнения задачи. Для этого с помощью действия
<a href="../../task_maker/help/index.html">Task maker</a> необходимо задать соответствующее условие
для задачи. При выполнении условия, то есть когда счетчик будет запущен, задача выполнится.
</p><h4>Delete counter</h4><p>Счетчик будет удален, все связи будут разрушены. Если переменные в других счетчиков зависят от
удаляемого счетчика, их расчет не будет производится. Поэтому, в результате разрушения связей,
возможна некорректная работа других счетчиков.
При удалении счетчика появится окно с подтверждением действия.</p><img class="materialboxed card-panel hoverable" src="images/help.counterDeleteConfirmation.png"><h4>Counter name</h4><p>Поле служит для ввода нового или изменения текущего имени счетчика. Будьте внимательными при
изменении имени счетчика. Переменные ссылаются на счетчики не по идентификатору, а по его имени. Это
сделано для того, чтобы счетчик, подключенный к разным объектам, мог ссылаться на разные счетчики
с одинаковыми именами. При смене имени счетчика необходимо поправить имена всех счетчиков на
которые ссылаются переменные. При смене имени счетчика появится подсказка, где буду указаны все
ссылки на имя счетчика.
</p><h4>Counter group</h4><p>Поле для ввода или изменения группы у счетчика. Группировка служит для удобства поиска и
фильтрации счетчиков.
</p><h4>Кнопка для редактирования групп счетчиков</h4><p>С помощью кнопки <a class="btn-floating waves-effect btn-small"><i class="material-icons">playlist_add</i></a>
можно отредактировать название группы счетчиков, добавить новую группу, удалить группу,
установить группу по умолчанию</p><ol><li>Add a new group (and enter the name of the new group below) - Добавить новую группу.
Для этого нужно ввести имя новой группы в поле ввода New group name</li><li>Edit the name of the selected group (and enter the new group name below) - Отредактировать
выбранное имя группы.
Для этого нужно ввести новое имя группы в поле ввода New group name</li><li>Set selected group as start in group selector - установить выбранную группу как
группу по умолчанию для Counter group. При создании нового счетчика будет выбираться эта группа.</li><li>Delete selected group with all counters included in this group - Удалить выбранную группу
и все счетчики, которые входят в эту группу. Все счетчики, входящие в эту группу,
будут удалены.
</li></ol><img class="materialboxed card-panel hoverable" src="images/help.groupEditor.png"><h4>Collector type</h4><p>Позволяет выбрать сборщик, который будет собирать или генерировать данные для счетчика.
Например, если вы хотите собирать данные по SNMP, необходимо выбрать сборщик SNMP.
Если необходимо проверить сетевую доступность хоста, нужно выбрать сборщик Ping.
Также можно разработать свой сборщик. После выбора сборщика необходимо установить
его параметры.</p><img class="materialboxed card-panel hoverable" src="images/help.chooseCollector.png"><h4>Параметры сборщика</h4><p>В зависимости от выбранного сборщика необходимо установить его параметры. Для каждого
сборщика параметры будут разные. Например, для сборщика Ping параметрами могут быть имя или
IP адрес удаленного хоста, интервал отправки
пакетов, размер пакета, количество отправленных пакетов, временной интервал ожидания пакета,
пока он не будет помечен как потерянный пакет. В качестве параметров сборщика или части
параметра могут выступать переменные. Например, можно создать описание для события о том, что
на сервере недостаточно оперативной памяти, включив в него переменные, значением которых
является информация об объеме оставшейся памяти на сервере:
"Free memory is %:HUMAN_FREE_MEMORY:%. Threshold %:HUMAN_FREE_MEMORY_LIMIT:%"</p><p>Для получения помощи по параметрам выбранного сборщика необходимо нажать на иконку с "?" в правом
верхнем углу.</p><img class="materialboxed card-panel hoverable" src="images/help.collectorParametersPing.png" width="1024"><h4>Units</h4><p>Единицы измерения для данных, полученных с помощью сборщиков. Для каждого счетчика можно
установить единицу измерения, в которой будут получены данные. Например это могут быть
Time, Bytes, Bits и другие. Корректность отображения данных зависит от выбранной единицы
измерения для полученных данных.
</p><h4>Кнопка для редактирования единиц измерения</h4><p>С помощью кнопки <a class="btn-floating waves-effect btn-small"><i class="material-icons">playlist_add</i></a>
можно отредактировать или добавить
новую единицу измерения. При нажатии на кнопку появится диалог редактирования.</p><ol><li>Add a new unit (and enter the parameters of the new unit below) - Добавить новую единицу
измерения. При добавлении новой единицы измерения необходимо ввести ее параметры</li><li>Edit the name of the selected unit (and enter the unit parameters below) - Изменить единицу
измерения. При изменении единицы измерения необходимо ввести ее параметры
</li><li>Delete selected unit with all counters in this unit - Удалить выбранную единицу измерения
и все счетчики, которые ее используют. Все счетчики, которые используют эту единицу измерения,
будут так же удалены.</li><li>Параметры для новой или редактируемой единицы измерения:<ol><li>Abbreviation - аббревиатура единицы измерения, например % (проценты), B (байты),
sec (секунды) и так далее</li><li>Prefixes - Префиксы единицы измерения, которые будут добавляться перед аббревиатурой или
будут использоваться самостоятельно. Префиксы необходим ввести через запятую. Например,
для Bytes это могут быть K,M,G,T, что в сочетании с аббревиатурой "B" даст KB,MB,GB,TB</li><li>Multipliers for each prefix - множители для каждого префикса. Количество множителей
должно быть такое же, как и количество префиксов. Например, для единицы измерения
Bytes и для префиксов K,M,G,T, множители могут быть
1024,1048576,1073741824,1099511627776. А для
единицы измерения Time и для префиксов ns,μs,ms,min,hours,days,weeks,months,years
множители могут быть 0.000000001,0.000001,0.001,60,3600,86400,604800,2592000,31536000</li><li>Use a prefix without an abbreviation where no abbreviation is used
(for example, for time) - если
установлен этот признак, то при отображении единицы измерения, будет показан только
префикс без аббревиатуры. Например, это актуально для единицы измерения - Time,
где к базовой аббревиатуре sec добавлять самостоятельные префиксы
ns,μs,ms,min,hours,days,weeks,months,years не нужно.
</li></ol></li></ol><img class="materialboxed card-panel hoverable" src="images/help.unitsEditor.png"><h4>Multiplier (depending of units)</h4><p>В зависимости от выбранной единицы измерения можно выбрать базовый множитель, для приведения
данных к стандарту. Например, сборщик Ping возвращает данные о времени прохождения пакетов
в миллисекундах. В этом случае необходимо выбрать ms в качестве базового множителя, для
приведения данных к стандартному sec.
</p><h4>Keep history (days)</h4><p>Сохранять исторические данные в течение указанного количества дней. Данные,
собранные позже указанного количества дней, будут удаляться для сохранения дискового пространства.
Вместе с данными будут удаляться те тренды, время усреднения для которых установлено менее
одного часа.
Если установлено 0, то данные не будут записаны в базу данных и будут удалятся из кэша
при каждом сохранении кэша в БД.
</p><h4>Keep trends (days)</h4><p>Сохранять тренды в течение указанного количества дней. Тренды, собранные позже указанного
количества дней, будут удаляться для сохранения дискового пространства. Параметр влияет только
на тренды с временем усреднения в один час или более.
Если установлено 0, то тренды создаваться не будут.
</p><img class="materialboxed card-panel hoverable" src="images/help.unitsAndKeeps.png" width="1024"><h4>Description</h4><p>Пояснение к счетчику, переменным счетчика, событиям обновления и так далее. Служит для
помощи в понимании назначения счетчика, его переменных и параметров.
</p><h3>LINKS</h3><p>Вкладка LINKS позволяет настроить подключение счетчика к объектам, с которых необходимо собирать
информацию. Кроме того, в этой вкладке настраиваются зависимости счетчика от родительских
счетчиков, благодаря которым будет запускаться сбор или генерация информации.</p><img class="materialboxed card-panel hoverable" src="images/help.links.png" width="1024"><h4>Update event</h4><p>Элемент служит для настройки событий, при наступлении которых будет происходить сбор данных по счетчику.
Если для счетчика событие Update event не настроено, ALEPIZ запустит сбор данных для него во
время запуска сервера или перезапуска. Если событие настроено, то при запуске сервера сбор
данных осуществляться не будет.</p><p>Для счетчиков, которые собирают данные с помощью активных сборщиков, ничего настраивать н нужно.
Эти сборщики самостоятельно собирают данные в зависимости от заложенных в них алгоритмов.
Инициализация активных счетчиков происходит один раз при старте сервера.
Например, сборщик Ping будет собирать данные с периодичностью, указанной в параметре Ping interval
Запуск сборщика происходит один раз при старте сервера, далее сборщик собирает данные самостоятельно.
Если для активных сборщиков установить событие, они будут инициализироваться каждый раз, когда
наступает указанное событие и не будут запускаться при старте сервера.</p><p>Для пассивных счетчиков необходимо настроить событие, после которого будут собираться данные.
Иначе сбор данных будет происходить один раз после запуска сервера.
Событием может служить время активного счетчика Timer для периодического сбора данных раз в
какое-то время. Либо это может быть предельное значение какого либо счетчика, после которого
необходимо сгенерировать событие. Например, это может быть минимально допустимый объем
свободного дискового пространства.</p><p>Может быть несколько событий, после которых будет происходить сбор данных по счетчику. Для создания
нового события служит кнопка "+" под событиями или вверху страницы.
Для удаления события служит "x" в правом верхнем углу
элемента с параметрами события. Знак "?" в правом верхнем углу выводит подсказку по функциям,
которые можно использовать для вычисления события. Для того, чтобы поменять порядок событий, необходимо
передвинуть панель с событием на требуемое место.</p><img class="materialboxed card-panel hoverable" src="images/help.updateEvents.png" width="1024"><h3>Update event generated by...</h3><p>Перед созданием нового события необходимо определиться с объектом, к которому привязан родительский
счетчик и который будет его генерировать.
Если в системном меню Object не выбран ни один объект, событие будет сгенерировано
родительским счетчиком, привязанным к тому же объекту, к которому привязан данный счетчик.
В заголовке события в этом случае будет надпись "Update event generated by <u>this object</u>".
Если объект выбран, то событие будет сгенерировано родительским счетчиком, привязанным к
выбранному объекту и в заголовке события будет указан выбранный объект.
</p><h4>Regular expression for filtering dependent objects....</h4><p>Поле "Regular expression for filtering dependent objects by object names. You can use variables only
from parent object. The variables will be replaced with values." появляется только если выбран
конкретный объект, от событий которого зависит текущий счетчик.
Оно может служить для фильтрации зависимых от события объектов по их имени. Если в поле указано
регулярное выражение, то при вычислении зависимых от события объектов дополнительно будет
применен фильтр по имени объекта: если имя зависимого объекта не соответствует регулярному выражению,
сбор данных для этого объекта не будет производиться. При вычислении регулярного выражения будут
использованы флаги "i" (игнорирование регистра при сопоставлении) и "g"
(глобальное сопоставление). В регулярном выражении можно использовать только
переменные, значения которых было вычислено в родительских объектах. Переменные, вычисляемые во
вкладке VARIABLES или в свойствах зависимого объекта, не могут быть использованы для формирования
регулярного выражения, т.к. их вычисление происходит после определения необходимости сбора данных
по счетчику.
</p><h4>Counter</h4><p>В данном поле выбирается счетчик объекта, от генерации значений которого будет зависеть текущий
счетчик. Например, при потере нескольких пакетов счетчика со сборщиком Ping, может быть
сгенерировано событие Packet loss, о котором придет уведомление администратору. Либо счетчик
Timer генерирует событие каждые 30 секунд, после которого будет производиться сбор данных
пассивными счетчиками, которые зависят от него.
Если рядом с родительским счетчиком присутствует надпись [NOT SHARED], значит есть объекты, к
которым привязан текущий счетчик и не привязан выбранный родительский счетчик. Для таких
объектов событие генерироваться не будет.
</p><h4>Update mode</h4><p>Данный элемент позволяет выбрать режим, в котором будет происходить генерация событий для
вычисления значения зависимого счетчика. Изменять режим генерации событий имеет смысл только
если есть логическое выражение, от которого зависит событие.</p><img class="materialboxed card-panel hoverable" src="images/help.updateEventMode.png"><ol><li>Update each time when expression value is true - генерировать событие каждый раз, когда
логическое выражение возвращает значение true</li><li>Update once when expression value is changed to true - генерировать событие один раз после
того, как логическое выражение изменило значение с false на true</li><li>Update once when expression value is changed to true and once when changed to false -
генерировать событие один раз после того, как логическое выражение изменило значение с
false на true и один раз после того, как логическое выражение изменило значение с true на
false</li><li>Update each time when expression value is changed to true and once when changed to false -
генерировать событие каждый после того, как логическое выражение возвращает значение
true и один раз после того, как логическое выражение изменило значение с true на
false</li><li>Update once when expression value is changed to false - генерировать событие один раз после
того, как логическое выражение изменило значение с true на false
</li></ol><h4>Logical expression</h4><p>В зависимости от результата вычисления этого логического выражения и режима, установленного в
Update, mode будет происходить генерация события для вычисление значения счетчика. Если логическое
выражение отсутствует, то генерация события будет происходить каждый раз, когда родительский
счетчик вернет какое-либо значение. Правила формирования этого логического выражения такие же, как и
правила формирования логических выражений для вычисления переменных во вкладке VARIABLES.</p><h4>Description</h4><p>Можно написать пояснение к созданному Update event</p><h3>Object linked to a counter</h3><p>С помощью этого элемента можно подключить или отключить объекты от счетчика.
При необходимости подключить к счетчику новые объекты, выберите объекты в системном меню Objects
и нажмите на ADD SELECTED OBJECTS.
Если нажать на крестик справа от объекта в Object linked to a counter, связь счетчика с объектом
будет удалена. Отключить все объекты от счетчика можно нажав на REMOVE ALL OBJECTS.
Все объекты отсортированы по алфавиту. При большом количестве подключенных объектов, снизу элемента
появится навигация в виде номеров страниц.</p><img class="materialboxed card-panel hoverable" src="images/help.linkedObjects.png"><h3>VARIABLES</h3><p>Переменные служат для:</p><ul class="browser-default"><li>Создания логического выражения с помощью которого будет принято решение о необходимости
вычисления значения зависимого счетчика</li><li>Вычисления параметров сборщика. Например, можно установить переменную
%:ZABBIX_HOSTNAME:% для сбора данных с Zabbix агента и при необходимости переопределять ее
в свойствах каждого объекта через действие Object properties. Либо установить динамически
 изменяемую важность события в зависимости от того, сколько осталось оперативной памяти
 на сервере</li><li>Динамического отображения данных о событии. То есть в сообщении о событии, как и в любой
другой параметр сборщика, можно включить переменные, например
"Idle disk time is %:MIN_IDLE_DISK_TIME:%%"</li><li>Создания динамического текста, который будет произносится при наступлении события,
например "На %:OBJECT_NAME:% время простоя дисковой подсистемы составляет
%:MIN_IDLE_DISK_TIME:%%"</li></ul><p>Переменные записываются как %:<ИМЯ_ПЕРЕМЕННОЙ>:% или %:?<ИМЯ_ПЕРЕМЕННОЙ>:%.</p><ul class="browser-default"><li>Переменная, записанная в формате %:<ИМЯ_ПЕРЕМЕННОЙ>:%
означает, что для вычисления значения счетчика необходимо вычислить значение переменной. Если
значение такой переменной вычислить не удается, вычисление значения счетчика производиться не
будет.</li><li>Формат переменной %:?<ИМЯ_ПЕРЕМЕННОЙ>:% используется для того, чтобы вычисление значения
счетчика не зависело от возможности вычисления переменной. Если значение переменной не может
быть вычислено, ее значение будет равно 0 при вычислении выражения и null
при использовании переменной в качестве параметра функции.
Таким образом условие %:?VARIABLE:% == 0 будет принимать значение 1 если значение переменной
равно нулю или оно неопределенно.
Для проверки того, удалось или нет вычислить значение переменной
необходимо использовать функцию isDefined(%:?<ИМЯ_ПЕРЕМЕННОЙ>:%)</li></ul><p>Переменные можно определить во вкладке VARIABLES. Кроме того, все переменные, которые были
определены в родительских счетчиках, будут доступны в текущем счетчике. Если переменную
не удалось вычислить и ее префиксом не является %:?, данные по счетчику собираться не будут.
Предопределенные переменные и переменные, которые определены в родительских счетчиках
можно посмотреть, развернув форму "Predefined and inherited variables"</p><blockquote>При формировании имен переменных, желательно придерживаться правила: имя переменной должно
содержать информацию,
к какому счетчику относится переменная (если в этом есть смысл) и для чего она предназначена.
Например, %:FREE_MEMORY_THRESHOLD:% или %:FREE_MEMORY_NODATA:% или %:SNMP_PORT:%. Лучше не
давать название переменной %:DONT_USE_ALERT_FOR_THIS_PROCESS:%, потому что если вы
используете ее в свойстве объекта для переопределения переменной счетчика, становится непонятно,
к какому счетчику относится переменная. Лучше назвать переменную %:SKIP_PROCESS_RESTART_ALERT:%</blockquote><p>Обычно для имен переменных используется нотация SNAKE_CASE, но можно использовать любую другую удобную
нотацию, например camelCase</p><h5>Конверсии</h5><p>Для удобства записи числовых значений переменных можно использовать предопределенные конверсии.
Например, для указания минимального лимита памяти в 4Gb нет необходимости переводить это число
в байты (4294967296) для сравнения с получаемым значением из счетчика. Можно использовать любые
конверсии из таблицы ниже. Система автоматически осуществит перевод в случае с данными - в байты,
а в случае с временем - в миллисекунды. Будьте внимательны с работой с временем: некоторые сборщики
используют в качестве единицы времени не миллисекунды, а секунды. В этом случае необходимо делать
преобразование значения конверсии в счетчике за счет деления значения на 1000.</p><table><thead><tr><th>Название</th><th>Описание</th><th>Множитель</th></tr></thead><tbody><tr><td>Kb</td><td>Килобайт</td><td>1 024</td></tr><tr><td>Mb</td><td>Мегабайт</td><td>1 048 576</td></tr><tr><td>Gb</td><td>Гигабайт</td><td>1 073 741 824</td></tr><tr><td>s</td><td>Секунды</td><td>1 000</td></tr><tr><td>m</td><td>Минуты</td><td>60 000</td></tr><tr><td>h</td><td>Часы</td><td>3 600 000</td></tr><tr><td>d</td><td>Дни</td><td>86 400 000</td></tr><tr><td>w</td><td>Недели</td><td>604 800 000</td></tr></tbody></table><p>Вкладка VARIABLES позволяет определить переменные двух типов:</p><ol><li>Переменные, значения которых вычисляется с использованием функций, работающих с историческими
данными
</li><li>Выражения, значения которых вычисляются используя арифметические и логические
операнды, а так же функции для обработки значений.
</li></ol><p>Для создания переменных основанных на исторических значениях, необходимо нажать на кнопку
<a class="btn-floating waves-effect btn-small"><i class="material-icons">add_box</i></a>. Кнопка
<a class="btn-floating waves-effect btn-small"><i class="material-icons">library_add</i></a> служит для создания вычисляемых переменных.
Для удаления переменной необходимо нажать на кнопку "x" в правом верхнем углу элемента с переменной.
Для получения справки по функциям и операндам необходимо нажать на кнопку "?" в правом верхнем
углу элемента с переменной. Для изменения порядка переменных, необходимо их передвинуть на
соответствующее место.</p><p>Некоторые переменные определены заранее:</p><ul class="browser-default"><li>OBJECT_NAME - Имя объекта для которого вычисляется значение счетчика</li><li>COUNTER_NAME - Имя текущего счетчика</li><li>PARENT_OBJECT_NAME - Имя родительского объекта от которого зависит вычисление текущего
счетчика, если установлена зависимость в Update events</li><li>PARENT_COUNTER_NAME - Имя родительского счетчика от которого зависит вычисление текущего
счетчика, если установлена зависимость в Update events</li><li>PARENT_VALUE - Значение, которое вернул родительский счетчик, от которого зависит вычисление
текущего счетчика, если установлена зависимость в Update events. Значение PARENT_VALUE может
отличаться от значения, полученного функциями, работающими с историческими значениями,
типа last(). Потому что исторические значения извлекаются из базы данных, а значение
PARENT_VALUE сервер возвращает сразу после получения данных от родительского счетчика и
базу оно могло еще не попасть.</li><li>UPDATE_EVENT_STATE - Если у текущего счетчика есть родительский счетчик, который генерирует
событие для вычисление текущего счетчика, то эта переменная принимает значение логического
выражения из Update event: 0 или 1.</li><li>UPDATE_EVENT_TIMESTAMP - Если у текущего счетчика есть родительский счетчик, который генерирует
событие для вычисления текущего счетчика, то значением этой переменной будет время генерации
такого события в миллисекундах с 01.01.1970</li><li>ALEPIZ_ID - числовой идентификатор экземпляра ALEPIZ. -1, если экземпляр ALEPIZ не определен.
Возвращается поле id из таблицы БД alepizNames, соответствующее
значению параметра indexOfOwnNode файла config\node.json. Можно использовать для
автоматизации в действиях Object creator, Object clone и Object editor при установке
принадлежности объекта определенному экземпляру ALEPIZ</li><li>ALEPIZ_NAME - название экземпляра ALEPIZ. Пустая строка, если экземпляр
ALEPIZ или ALEPIZ_ID не определен.
Возвращается поле name из таблицы БД alepizNames, id которого соответствует
значению параметра indexOfOwnNode файла config\node.json.
Обычно используется в информационных целях.</li><li>PREV_ACTION_RESULT - Переменная используется только в задачах (Task maker), состоящих из
нескольких действий. В этом случае значением переменной становится результат, возвращаемый
предыдущим действием в задаче.
</li></ul><img class="materialboxed card-panel hoverable" src="images/help.variables.png" width="1024"><h3>Создание переменных, вычисляемых на основе исторических значений.</h3><p>Переменные, вычисляемые на основе исторических значений, используют функции, которые получают
исторические данные из базы данных, обрабатывают их и возвращают значение.
Например, это может быть функция last(), возвращающая последнее записанное значение счетчика
в базу данных (если она вызывается без аргументов). Либо функция nodata(time), возвращающая
true, если данных не было определенный интервал времени. Помощь по функциям можно получить,
выбрав соответствующую функцию и нажав на значок "?" в правом верхнем углу формы ввода параметров
переменной.
</p><img class="materialboxed card-panel hoverable" src="images/help.historicalVariable.png" width="1024"><h5>Ниже приводится описание параметров переменных:</h5><h4>Object</h4><p>Объект, у которого будут запрошены необходимые исторические данные. Кнопкой
<a class="btn-floating waves-effect btn-small"><i class="material-icons">swap_horiz</i></a> можно переключить тип объекта.
Объекты могут быть следующих типов:</p><ul class="browser-default"><li>THIS OBJECT - исторические данные будут получены со счетчика, привязанного к тому же объекту,
к которому привязан текущий счетчик.</li><li><Имя объекта> - Исторические данные будут получены со счетчика какого-то конкретного объекта.
 Для того, чтобы выбрать объект, нужно в системном меню Objects выделить необходимый объект,
затем переключить тип объекта в поле Object на требуемый объект</li><li>Variable name - Имя объекта может задаваться переменной. Для этого в системном меню Objects
необходимо выбрать один из объектов, к которому подключен требуемый счетчик.
Это позволит в дальнейшем выбрать необходимый счетчик. Далее необходимо
переключить тип объекта на Variable name. После этого в поле ввода необходимо указать
название переменной. Название переменной может быть с или без знаков %: и :%.
</li></ul><h4>Counter</h4><p>Необходимо выбрать счетчик. Требуемые исторические данные будут запрашиваться у пары
Объект-счетчик.</p><p>Если в качестве типа объекта выбрано Variable name, для выбора
требуемого счетчика нужно в системном меню Objects выбрать объект, к которому подключен
требуемый счетчик. После этого переключателем типа объектов еще раз выбрать тип
объекта Variable name.</p><p>Надпись [NOT SHARED] у имени счетчика означает,
что не все объекты, подключенные к текущему счетчику, так же имеют подключение к счетчику,
из исторических значений которого планируется вычислить переменную. В результате этого
переменная будет вычислена не для всех объектов, к которым подключен текущий счетчик.</p><h4>Variable name</h4><p>Имя новой переменной. Переменным желательно давать такие имена, чтобы по их названию можно было
понять к какому счетчику они относятся и для чего они предназначены. Имена переменных
чувствительны к регистру. Для имен переменных можно использовать любую удобную нотацию записи,
например SNAKE_CASE или camelCase. Имя переменной создается автоматически на основе названия
счетчика в SNAKE_CASE нотации. В дальнейшем имя переменной можно исправить. Любую переменную
можно переопределить с помощью свойства объекта. Для этого необходимо с помощью действия
Objects properties задать свойство объекту и дать ему имя переменной, которую необходимо
переопределить.
</p><h4>Function</h4><p>Необходимо выбрать функцию, с помощью которой будут получены и обработаны исторические данные.
Для получения справки по функциям необходимо выбрать соответствующую функцию и нажать на
значок "?" в правом верхнем углу формы ввода параметров переменной.
</p><h4>Function parameters</h4><p>Поле ввода параметров для функции. В качестве разделителя параметров используется запятая. В
качестве параметра так же можно указать переменную.</p><h4>Description</h4><p>Можно оставить описание переменной. Описание будет отображаться у зависимых объектов в форме
Predefined and inherited variables.
</p><h5>Временные интервалы и количественные значения в параметрах функций.</h5><p>В качестве параметров исторических функций могут использоваться как временные интервалы, так и
количественные значения. Если требуется указать количество значений,
перед числом необходимо поставить знак '#'. Если число будет без знака '#', то оно будет
интерпретироваться как временной интервал. Например:</p><ol><li>nodata(5m) - нет данных по счетчику за последние 5 минут</li><li>avg(#5) - арифметическое среднее за 5 последних сохраненных значений</li><li>min(180000) - минимальное значение, полученное за последние 3 минуты</li><li>min(#180000) - минимальное значение, полученное за последние 180000 значений</li></ol><h5>Префикс "!": повышение точности в работе с историческими значениями</h5><blockquote>При использовании временных интервалов и количественных значений в исторических функциях
могут возникать неточности в вычислениях в случае, если в истории присутствует
недостаточное количество данных. Для исключения неточностей можно использовать
префикс "!" перед параметром функции, который отвечает за количество требуемых
исторических данных или за временной интервал. Обычно это первый параметр. В этом случае,
если ALEPIZ не может найти 90% от требуемого количества значений, возвращается
результат undefined. Например, если для функции max(#!20) (или max(!#20)) в истории
присутствует только 10
значений, то функция вычисляться не будет и вернется результат undefined. Если для функции
min(!5m) в истории удалось найти данные только за 3 последние минуты, то функция так же
не будет вычисляться и вернется результат undefined, даже если в истории есть значения за
другой промежуток времени. Таким образом, например, функция min(!30m) в этом же примере может
вернуть результат, потому что в истории присутствуют данные для интервала времени 30 минут.
Если при запросе данных за временной интервал возвращается 0 или 1 значение, в любом случае
будет возвращен результат undefined.
Для определения факта присутствия необходимых данных в истории для временных интервалов,
вычисляется средний интервал
времени между собранными данными и если от конечной точки временного интервала до последней
записи в истории значений интервал времени превышает средний интервал времени между данными + 20%,
то считается, что требуемых данных в истории нет. Например, при запросе данных с текущего
времени 10:25:00 за интервал времени 5 минут, вычисляем средний интервал между данными,
полученными в течение 5 минут.
Например он составляет 30 секунд.
Далее смотрим, присутствуют ли данные в интервале от 10:20:00 до
(10:20:00 + 30 секунд + 20% от 30 секунд),
то есть ищем данные между 10:20:00 и 10:20:36. Если данные есть, вычисляем функцию, если нет,
то возвращаем undefined</blockquote><h4>Примеры использования исторических функций:</h4><table><thead><tr><th>Переменная</th><th>Выражение</th><th>Описание</th></tr></thead><tbody><tr><td>FREE_MEMORY_NODATA</td><td>Free memory:nodata(5m)</td><td>Возвратит true если по счетчику Free memory не было данных в течение 5 минут</td></tr><tr><td>SERVICE_START_TIME</td><td>Service start time:lastRob(#%:NUMBER_OF_SAMPLE_VALUES:%, #0, 0)</td><td>Время старта сервиса за исключением статистических выбросов за последние
%:NUMBER_OF_SAMPLE_VALUES:% стартов. В счетчик Service start time записывается
время каждого старта. Эта переменная позволяет вычислить старты сервиса по
расписанию и исключить старты сервисов вручную в нестандартное время. Служит
для определения расписания старта сервиса.</td></tr><tr><td>LAST_SERVICE_STATES</td><td>Service state:min(#4)</td><td>Минимальное значение счетчика Service state за последние 4 значения. Можно
использовать для определения, был ли последнее время сервис запущен. Для
запущенного сервиса это значение должно равняться 0</td></tr><tr><td>SERVICE_STARTS_COUNT_AT_CURRENT_WEEK_DAY</td><td>Service start week day:count(#!%:NUMBER_OF_SAMPLE_VALUES_FOR_WEEK_DAYS:%, , %:CURRENT_WEEK_DAY:%, 0)</td><td>Сколько раз в текущий день недели сервис запускался. Данные берутся за
последние %:NUMBER_OF_SAMPLE_VALUES_FOR_WEEK_DAYS:% дней. Служит для определения,
является ли текущий день недели рабочим для сервиса
</td></tr></tbody></table><h3>Создание переменных, вычисляемых на основе выражений.</h3><p>Переменные, вычисляемые на основе выражений служат для генерирования новых данных или
преобразования полученных данных.</p><img class="materialboxed card-panel hoverable" src="images/help.expressionVariable.png" width="1024"><h5>Ниже приводится описание параметров переменных:</h5><h4>Variable name</h4><p>Имя новой переменной. Переменным желательно давать такие имена, чтобы по их названию можно было
понять к какому счетчику они относятся и для чего они предназначены. Имена переменных
чувствительны к регистру. Для имен переменных можно использовать любую удобную нотацию записи,
например SNAKE_CASE или camelCase. Любую переменную
можно переопределить с помощью свойства объекта. Для этого необходимо с помощью действия
Objects properties задать свойство объекту и дать ему имя переменной.</p><h4>Expression</h4><p>Выражение для вычисления значения переменной. В выражении можно использовать другие переменные,
логические и арифметические операнды, а так же функции. Для получения справки по операндам
и функциям необходимо нажать на значок "?" в правом верхнем углу формы ввода параметров переменной.
Логические выражения возвращают значение 0 в случае false и 1 в случае true.</p><h4>Description</h4><p>Можно оставить описание переменной. Описание будет отображаться у зависимых объектов в форме
Predefined and inherited variables.
</p><h4>Примеры выражений</h4><table><thead><tr><th>Переменная</th><th>Выражение</th><th>Описание</th></tr></thead><tbody><tr><td>IDLE_DISK_TIME_PERIOD</td><td>3m</td><td>С помощью конверсии переменной IDLE_DISK_TIME_PERIOD присваивается значение 3 минуты (180000)</td></tr><tr><td>FULL_HOSTNAME</td><td>getValueFromJSONStr(%:PARENT_VALUE:%, "hostname" )</td><td>Функцией getValueFromJSONStr() разбирается структура JSON, записанная как строка в
значении, полученным от родительского счетчика и из этой структуры получаем значение
ключа 'hostname'.</td></tr><tr><td>SHORT_HOSTNAME</td><td><pre>ifElse( %:FULL_HOSTNAME:%,
    ifElse( testRE(%:FULL_HOSTNAME:%, "^.+\..+?[^0-9]$"),
        toUpperCase( replaceRE(%:FULL_HOSTNAME:%, "^([^\.]+)\.?.+$", "$1") ),
        toUpperCase( %:FULL_HOSTNAME:%)
    ),
    %:IP_ADDRESS:% )</pre></td><td>В результате этого выражения в зависимости от значения переменной %:FULL_HOSTNAME:%
получаем либо короткое имя хоста без домена в верхнем регистре, либо, если переменная
%:FULL_HOSTNAME:% пустая, IP адрес из переменной %:IP_ADDRESS:%</td></tr><tr><td>HUMAN_FREE_MEMORY и HUMAN_FREE_MEMORY_LIMIT</td><td><pre>toHuman(%:PARENT_VALUE:%, 'Bytes')
и
toHuman(%:FREE_MEMORY_LIMIT:%, 'Bytes')</pre></td><td>Преобразуем полученное от родительского счетчика значение %:PARENT_VALUE:% и
значение переменной %:FREE_MEMORY_LIMIT:% из байт в удобный человеку формат
для последующего отображения в динамически сформированном описании события:
"Free memory is %:HUMAN_FREE_MEMORY:%. Threshold %:HUMAN_FREE_MEMORY_LIMIT:%"
</td></tr></tbody></table><h3>LOG</h3><p>Вкладка LOG служит для просмотра системных сообщений о работе выбранного счетчика. Чаще
всего наличие сообщений означает некорректную работу и помогают найти ошибки в его настройке.</p><img class="materialboxed card-panel hoverable" src="images/help.log.png" width="1024"><p>Можно просматривать файлы с сообщениями за текущий или предыдущие дни (Select File),
осуществлять поиск (Search) в прямом и
обратном направлении (↑), использовать в поиске регулярные выражения (re) и
менять кодировку текста (Code page).
Если системные сообщения для счетчика отсутствуют, вкладка LOG будет неактивной.
Лог файлы для счетчиков находятся в каталоге с остальными лог файлами ALEPIZ (обычно это
каталог logs) в подкаталоге counters. В качестве имени для файла используется counterID.
Количество дней за которые можно просматривать сообщения, регулируется системной настройкой
глубины ротации логов.
</p><h3>IMPORT\EXPORT</h3><p>Вкладка используется для импорта или экспорта настроек счетчика.
С ее помощью можно передавать настройки между различными экземплярами  ALEPIZ.
Для передачи данных используется объект в формате JSON, который отображается в
редакторе. Редактор служит для того, можно было вручную вносить изменения в
экспортируемый или импортируемый объект с настройками счетчика.</p><img class="materialboxed card-panel hoverable" src="images/help.importExport.png" width="1024"><h4>Формат импортируемого и экспортируемого объекта</h4><pre>{
    &quot;name&quot;: &lt;counter name&gt;
    &quot;keepHistory&quot;: &lt;number of days to store historical data&gt;,
    &quot;keepTrends&quot;: &lt;number of days to store averages of historical data (trends)&gt;,
    &quot;description&quot;: &lt;counter description&gt;,
    &quot;disabled&quot;: &lt;disable or enable counter (true|false)&gt;,
    &quot;debug&quot;: &lt;enable or disable counter debugging (true|false)&gt;,
    &quot;taskCondition&quot;: &lt;use a counter as a task execution condition (true|false)&gt;,
    &quot;collectorID&quot;: &lt;collector name (collector directory name)&gt;,
    &quot;groupName&quot;: &lt;counter group name&gt;,
    &quot;unitName&quot;: &lt;counter unit name&gt;,
    &quot;sourceMultiplier&quot;: &lt;multiplier for the value of the variable from the unit&gt;,
    &quot;collectorParameters&quot;: [ &lt;collector parameter arrays&gt;
        {
            &quot;name&quot;: &lt;parameter name&gt;,
            &quot;value&quot;: &lt;parameter value&gt;
        },
        ...
    ],
    &quot;linkedObjects&quot;: [ &lt;array of names for counter linked objects&gt;
        {
            &quot;name&quot;: &lt;linked object name&gt;
        }
    ],
    &quot;updateEvents&quot;: [ &lt;array of update events&gt;
        {
            &quot;counterName&quot;: &lt;update event parent counter name&gt;,
            &quot;name&quot;: &lt;the name of the object for the update event, or null for the current object&gt;,
            &quot;expression&quot;: &lt;update event expression&gt;,
            &quot;mode&quot;: &lt;update event mode&gt;:
                1: Update once when expression value is changed to true and result is changed to true
                2: Update once when expression value is changed to true and once when changed to false and result is changed to true or false
                3: Update each time when expression value is true and once when changed to false and result is changed to true or false
                4: Update once when expression value is changed to false and result is changed to false,
            &quot;description&quot;: &lt;update event description&gt;
            &quot;objectFilter&quot;: &lt;object filter regExp&gt;,
            &quot;updateEventOrder&quot;: &lt;current update event order&gt;
        }
    ],
    &quot;variables&quot;: [ &lt;array of historical or expression variables&gt;
        { &lt;historical variable&gt;
            &quot;name&quot;: &lt;variable name&gt;,
            &quot;objectName&quot;: &lt;the name of the object to receive data for the variable. null for
                the current object or for an object name that is defined by a variable&gt;,
            &quot;parentCounterName&quot;: &lt;the name of the parent counter to get data for the variable&gt;,
            &quot;function&quot;: &lt;historical function name&gt;,
            &quot;functionParameters&quot;: &lt;comma separated historical function parameters&gt;,
            &quot;objectVariable&quot;: variable to define the name of the object that is used to obtain historical data&gt;,
            &quot;description&quot;: &lt;variable description&gt;,
            &quot;variableOrder&quot;: &lt;current variable order&gt;
        },
        { &lt;expression variable&gt;
            &quot;name&quot;: &lt;variable name&gt;,
            &quot;expression&quot;: &lt;expression to evaluate the value of a variable&gt;,
            &quot;description&quot;: &lt;variable description&gt;,
            &quot;variableOrder&quot;: &lt;current variable order&gt;
        }
    ]
}</pre><h4>Описание интерфейса управления импортом и экспортом:</h4><img class="materialboxed card-panel hoverable" src="images/help.importExportButtons.png"><div class="row"><div class="col s12 m12 l4">GENERATE - генерировать данные для экспорта параметров редактируемого счетчика. Параметры
подставляются из web интерфейса действия Counter settings. Можно открыть счетчик на
редактирование, изменить требуемые параметры и, без сохранения изменений, создать
объект JSON для экспорта. При необходимости, экспортируемые параметры можно отредактировать
вручную в редакторе данных экспорта и импорта.
При создании данных для экспорта появится окно с информацией об объектах и счетчиках,
от которых зависит экспортируемый счетчик. При нажатии на ссылки будут открываться действия
для редактирования счетчиков или объектов, с помощью которых также можно произвести экспорт
данных.</div><div class="col s12 m12 l8"><img class="materialboxed card-panel hoverable" src="images/help.ImportExportGenerateAssociations.png"></div></div><div class="row"><div class="col s12 m12 l4">APPLY - применить данные из редактора импорта и экспорта к счетчику.
Импортируемые данные будут загружены в web
интерфейс действия Counter settings, без сохранения в базу данных.
Для сохранения изменений счетчика необходимо запустить действие Counter settings на выполнение.
Таким образом, перед сохранением, можно внести изменения в импортируемые настройки счетчика.
При необходимости, параметры можно отредактировать вручную в редакторе данных для экспорта и
импорта.
Если при анализе импортируемых данных было обнаружено, что в системе отсутствуют объекты
или счетчики, от которых зависит импортируемый счетчик, будет выведено соответствующее предупреждение.</div><div class="col s12 m12 l8"><img class="materialboxed card-panel hoverable" src="images/help.importExportImportWarning.png"></div></div><p>EXPORT - сохранить данные из редактора экспорта и импорта в файл. Имя файла формируется
автоматически из названия счетчика. Расширение файла будет .json</p><p>IMPORT - загрузить данные счетчика из файла в редактор импорта и экспорта данных. Производится
поиск файлов с расширением .json. Для того, чтобы применить загруженные данные к счетчику в web
интерфейс действия Counter settings, необходимо нажать на APPLY.</p><p>IMPORT AND APPLY - загрузить данные счетчика из файла в редактор импорта и экспорта данных и
применить загруженные данные к счетчику. Данные будут загружены только в web интерфейс действия,
без сохранения в базу данных.
Для сохранения изменений счетчика необходимо запустить действие Counter settings на выполнение.</p><p>Skip linked objects - Не импортировать, не экспортировать и не применять информацию об объектах,
подключенных к счетчику.</p></div></div></main></body></html>